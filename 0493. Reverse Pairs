Given an integer array nums, return the number of reverse pairs in the array.
A reverse pair is a pair (i, j) where:
0 <= i < j < nums.length and
nums[i] > 2 * nums[j].

Solution:
class Solution {
void _merge(vector<int>& nums, int low, int mid, int high, int &reversePairCount) {
    int leftInd = low, rightInd = mid+1, r = rightInd, temp[high-low+1], tempInd = 0, counter = 0;
    // 4 6 8,  1 2 3
    while(leftInd<=mid) {
        while( r<=high && (nums[leftInd] > (long)2*nums[r]) ) counter++, r++;
        reversePairCount+= counter;
        while( rightInd<=high && nums[rightInd]<=nums[leftInd] ) {
            temp[tempInd++] = nums[rightInd++];
        }
        temp[tempInd++] = nums[leftInd++];
    }
    while(rightInd<=high) {
        temp[tempInd++] = nums[rightInd++];
    }
    for(int i=0; i<tempInd; i++) nums[low++] = temp[i];
}

void _mergeSort(vector<int>& nums, int low, int high, int &reversePairCount) {
    if(low < high) {
        int mid = low + (high-low)/2;
        _mergeSort(nums, low, mid, reversePairCount);
        _mergeSort(nums, mid+1, high, reversePairCount);
        _merge(nums, low, mid, high, reversePairCount);
    }
}
public:
int reversePairs(vector<int>& nums) {
    int reversePairCount = 0;
    int sz = nums.size();
    if(sz<=1) return reversePairCount;
    _mergeSort(nums, 0, sz-1, reversePairCount);
    return reversePairCount;
}
};

Example 1:
Input: nums = [1,3,2,3,1]
Output: 2
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1

Example 2:
Input: nums = [2,4,3,5,1]
Output: 3
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1
(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1
